<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Custom Grist Widget with x-data-spreadsheet</title>

    <!-- Подключение CSS библиотек -->
    <link rel="stylesheet" href="https://unpkg.com/x-data-spreadsheet@1.1.9/dist/xspreadsheet.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.13.1/css/bootstrap-select.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="stylesheet" href="styles.css"> 
</head>
<body>

<div class="spreadsheet-container">
    <!-- Кнопка фильтра -->
    <button class="btn btn-primary" type="button" data-toggle="collapse" data-target="#filter-panel" aria-expanded="false" aria-controls="filter-panel" id="filter-button">
        <i class="fas fa-filter"></i>
    </button>

    <!-- Панель фильтров -->
    <div class="collapse" id="filter-panel">
        <div class="row filter-row">
            <div class="col-12">
                <input type="text" id="date-range" class="form-control" placeholder="Выберите диапазон дат">
            </div>
        </div>
        <div class="row filter-row">
            <div class="col-md-6 mb-3">
                <select id="bank-filter" class="selectpicker" multiple data-live-search="true" title="Банк"></select>
            </div>
            <div class="col-md-6 mb-3">
                <select id="dropovod-filter" class="selectpicker" multiple data-live-search="true" title="Дроповод"></select>
            </div>
        </div>
        <div class="row filter-row">
            <div class="col-md-6 mb-3">
                <select id="status-filter" class="selectpicker" multiple data-live-search="true" title="Статус"></select>
            </div>
            <div class="col-md-6 mb-3">
                <select id="method-filter" class="selectpicker" multiple data-live-search="true" title="Метод"></select>
            </div>
        </div>
        <div class="row filter-row">
            <div class="col-md-6 mb-3">
                <select id="platform-filter" class="selectpicker" multiple data-live-search="true" title="Площадка"></select>
            </div>
            <div class="col-md-6 mb-3">
                <select id="project-filter" class="selectpicker" multiple data-live-search="true" title="Бухгалтерия Проект"></select>
            </div>
        </div>
        <div class="row filter-row">
            <div class="col-md-6 mb-3">
                <select id="operation-filter" class="selectpicker" multiple data-live-search="true" title="Бухгалтерия Операция"></select>
            </div>
            <div class="col-md-6 mb-3">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="in-work-filter">
                    <label class="form-check-label" for="in-work-filter">
                        Отобразить "В работе"
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Контейнер для таблицы -->
    <div id="x-spreadsheet-demo"></div>
</div>

<!-- Подключение JS библиотек -->
<script src="libs/xspreadsheet.js"></script>
<script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.13.1/js/bootstrap-select.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<!-- Ваши собственные JS файлы -->
<script>
    // filters.js
    
    const DATE_RANGE = {
        start: null,
        end: null
    };
    
    const FILTERS_DB1 = {
        bank: [],
        dropovod: [],
        status: [],
        method: [],
        platform: [],
        inWork: false 
    };
    
    const FILTERS_DB2 = {
        project: [],
        operation: []
    };
    
    const excludedDropovods = ['Consult Kayos', 'Consult Titan'];
    
    const parseDate = (value) => {
        if (!value) return null;
        if (value instanceof Date) return value;
        if (typeof value === 'string') {
            const [datePart, timePart = '00:00'] = value.split(' ');
            const [day, month] = datePart.split('.');
            const year = new Date().getFullYear();
            return new Date(`${year}-${month}-${day}T${timePart}:00`);
        }
        return null;
    };
    
    const isDateInRange = (dateValue) => {
        if (!DATE_RANGE.start || !DATE_RANGE.end) return true;
        const date = parseDate(dateValue);
        return date && date >= DATE_RANGE.start && date <= DATE_RANGE.end;
    };
    
    const applyFilters = (record, filters, applyDate = true, dateField = 'Дата_BLOCK') => {
        const { bank, dropovod, status, method, platform } = filters;
    
        const fieldChecks = [
            { field: 'Банк', filter: bank },
            { field: 'Дроповод', filter: dropovod },
            { field: 'Статус', filter: status },
            { field: 'Метод', filter: method },
            { field: 'Площадка', filter: platform }
        ];
    
        for (const { field, filter } of fieldChecks) {
            if (filter.length === 0) continue; 
            const recordValue = record[field];
            const values = Array.isArray(recordValue) ? recordValue : [recordValue];
            const hasMatch = values.some(value => filter.includes(value));
            if (!hasMatch) return false;
        }
    
        if (applyDate) {
            if (!record[dateField]) return false;
            if (!isDateInRange(record[dateField])) return false;
        }
    
        return true;
    };
    
    const isExcludedDropovod = (dropovodValue) => {
        if (Array.isArray(dropovodValue)) {
            return dropovodValue.some(dropovod => excludedDropovods.includes(dropovod));
        }
        return excludedDropovods.includes(dropovodValue);
    };
    
    const applyCustomFiltersDB1 = (record) => {
        const status = Array.isArray(record['Статус']) ? record['Статус'] : [record['Статус']];
        const isInWork = FILTERS_DB1.inWork && status.includes('в работе');
    
        if (isExcludedDropovod(record['Дроповод'])) return false;
    
        if (isInWork) {
            return applyFilters(record, FILTERS_DB1, false);
        } else {
            const applicableDateField = status.includes('проблема') ? 'Приёмка' : 'Дата_BLOCK';
            return applyFilters(record, FILTERS_DB1, true, applicableDateField);
        }
    };
    
    const applyCustomFiltersDB2 = (record) => {
        const dateFilter = isDateInRange(record['Бухгалтерия_Дата']);
        if (!dateFilter) return false;
    
        const { project, operation } = FILTERS_DB2;
    
        const projectFilter = project.length === 0 || (Array.isArray(record['Бухгалтерия_Проект']) 
            ? record['Бухгалтерия_Проект'].some(p => project.includes(p)) 
            : project.includes(record['Бухгалтерия_Проект']));
    
        const operationFilter = operation.length === 0 || (Array.isArray(record['Бухгалтерия_Операция']) 
            ? record['Бухгалтерия_Операция'].some(o => operation.includes(o)) 
            : operation.includes(record['Бухгалтерия_Операция']));
    
        return projectFilter && operationFilter;
    };


    
</script>
    
<script>

    // UI.js
    
    function populateFilterOptions() {
        const uniqueValues = (field) => {
            const values = mappedRecords.flatMap(r => {
                let value = r[field];
                if (Array.isArray(value)) {
                    return value;
                }
                return [value];
            }).filter(Boolean);
            return [...new Set(values)];
        };
    
        const filterFields = {
            'bank-filter': 'Банк',
            'dropovod-filter': 'Дроповод',
            'status-filter': 'Статус',
            'method-filter': 'Метод',
            'platform-filter': 'Площадка',
            'project-filter': 'Бухгалтерия_Проект',
            'operation-filter': 'Бухгалтерия_Операция'
        };
    
        Object.entries(filterFields).forEach(([selectId, fieldName]) => {
            const select = document.getElementById(selectId);
            const options = uniqueValues(fieldName).map(value => `<option value="${value}">${value}</option>`).join('');
            select.innerHTML = `
                <option value="all">Все</option>
                ${options}
            `;
        });
    
        $('.selectpicker').selectpicker('refresh');
    }
    
    // UI.js
    
    function setupFilterEventListeners() {
        $('.selectpicker').on('changed.bs.select', function(e, clickedIndex, isSelected, previousValue) {
            const selectId = $(this).attr('id');
            let selectedValues = $(this).val() || [];
    
            if (clickedIndex === 0) {
                if (isSelected) {
                    $(this).selectpicker('selectAll');
                    $(this).selectpicker('deselect', 'all');
                    selectedValues = $(this).val() || [];
                } else {
                    $(this).selectpicker('deselectAll');
                    selectedValues = [];
                }
            }
    
            const filterValue = selectedValues.filter(v => v !== 'all');
    
            switch (selectId) {
                case 'bank-filter':
                    FILTERS_DB1.bank = filterValue;
                    break;
                case 'dropovod-filter':
                    FILTERS_DB1.dropovod = filterValue;
                    break;
                case 'status-filter':
                    FILTERS_DB1.status = filterValue;
                    break;
                case 'method-filter':
                    FILTERS_DB1.method = filterValue;
                    break;
                case 'platform-filter':
                    FILTERS_DB1.platform = filterValue;
                    break;
                case 'project-filter':
                    FILTERS_DB2.project = filterValue;
                    break;
                case 'operation-filter':
                    FILTERS_DB2.operation = filterValue;
                    break;
            }
    
            applyFiltersAndRender();
        });
    
        $('#in-work-filter').on('change', function() {
            FILTERS_DB1.inWork = $(this).is(':checked');
            applyFiltersAndRender();
        });
    
        if (!window.flatpickrInstance) {
            window.flatpickrInstance = flatpickr("#date-range", {
                mode: "range",
                dateFormat: "d.m.Y",
                onClose: function(selectedDates) {
                    DATE_RANGE.start = selectedDates[0] || null;
                    if (selectedDates[1]) {
                        DATE_RANGE.end = new Date(selectedDates[1]);
                        DATE_RANGE.end.setHours(23, 59, 59, 999);
                    } else {
                        DATE_RANGE.end = null;
                    }
                    applyFiltersAndRender();
                }
            });
        }
    }

    
</script>

<script>

    // db.js
    
    function processBankRecords(filteredRecordsDB1) {
        const bankMethodMap = {},
            bankPricesMap = {},
            bankCountsMap = {},
            bankProfitsMap = {},
            bankProblemCountsMap = {},
            bankBlockCountsMap = {},
            bankBlockSumMap = {};
    
        let totalPrices = 0,
            totalPricesCount = 0,
            totalBanksCount = 0,
            totalProfits = 0,
            totalProfitsCount = 0,
            totalProblemCount = 0,
            totalBlockCount = 0,
            totalBlockAmount = 0;
    
        filteredRecordsDB1.forEach(record => {
            const bank = Array.isArray(record['Банк']) ? record['Банк'][0] : record['Банк'];
            const method = Array.isArray(record['Метод']) ? record['Метод'][0] : record['Метод'];
            const price = parseFloat(record['Цена']);
            const profit = parseFloat(record['Профит']);
            const status = Array.isArray(record['Статус']) ? record['Статус'] : [record['Статус']];
            const blockAmount = parseFloat(record['BLOCK']) || 0;
    
            const isProblem = status.includes('проблема');
    
            if (bank && method) {
                bankMethodMap[method] = bankMethodMap[method] || new Set();
                bankMethodMap[method].add(bank);
    
                bankPricesMap[method] = bankPricesMap[method] || {};
                bankPricesMap[method][bank] = bankPricesMap[method][bank] || [];
    
                bankCountsMap[method] = bankCountsMap[method] || {};
                bankCountsMap[method][bank] = (bankCountsMap[method][bank] || 0);
    
                bankProfitsMap[method] = bankProfitsMap[method] || {};
                bankProfitsMap[method][bank] = bankProfitsMap[method][bank] || [];
    
                bankBlockSumMap[method] = bankBlockSumMap[method] || {};
                bankBlockSumMap[method][bank] = (bankBlockSumMap[method][bank] || 0);
    
                if (!isProblem) {
                    if (!isNaN(price)) {
                        bankPricesMap[method][bank].push(price);
                        totalPrices += price;
                        totalPricesCount += 1;
                    }
    
                    bankCountsMap[method][bank] += 1;
                    totalBanksCount += 1;
    
                    if (!isNaN(profit)) {
                        bankProfitsMap[method][bank].push(profit);
                        totalProfits += profit;
                        totalProfitsCount += 1;
                    }
                }
    
                if (isProblem) {
                    bankProblemCountsMap[method] = bankProblemCountsMap[method] || {};
                    bankProblemCountsMap[method][bank] = (bankProblemCountsMap[method][bank] || 0) + 1;
                    totalProblemCount += 1;
                }
    
                if (status.includes('блокировка')) {
                    bankBlockCountsMap[method] = bankBlockCountsMap[method] || {};
                    bankBlockCountsMap[method][bank] = (bankBlockCountsMap[method][bank] || 0) + 1;
                    totalBlockCount += 1;
                }
    
                if (status.includes('блокировка') && !isNaN(blockAmount)) {
                    bankBlockSumMap[method][bank] += blockAmount;
                    totalBlockAmount += blockAmount;
                }
            }
        });
    
        return {
            bankMethodMap,
            bankPricesMap,
            bankCountsMap,
            bankProfitsMap,
            bankProblemCountsMap,
            bankBlockCountsMap,
            bankBlockSumMap,
            totalPrices,
            totalPricesCount,
            totalBanksCount,
            totalProfits,
            totalProfitsCount,
            totalProblemCount,
            totalBlockCount,
            totalBlockAmount
        };
    }
    
    
    function setCell(row, col, text, format) {
        setCellText(row, col, text, 0);
        if (format) {
            setCellStyle(row, col, 'format', format);
        }
    }
    
    function renderBankData(bankData) { 
        const {
            bankMethodMap,
            bankPricesMap,
            bankCountsMap,
            bankProfitsMap,
            bankProblemCountsMap,
            bankBlockCountsMap,
            totalPrices,
            totalPricesCount,
            totalBanksCount,
            totalProfits,
            totalProfitsCount,
            totalProblemCount,
            bankBlockSumMap,
            totalBlockAmount,
            totalBlockCount
        } = bankData;
    
        const averagePrice = totalPricesCount > 0 ? (totalPrices / totalPricesCount).toFixed(2) : '0.00';
        const averageProfit = totalProfitsCount > 0 ? (totalProfits / totalProfitsCount).toFixed(2) : '0.00';
        const sumProfit = totalProfits.toFixed(2);
    
        let colIndex = 1;
        const methodColIndexes = {};
    
        Object.keys(bankMethodMap).forEach(method => {
            const banks = Array.from(bankMethodMap[method]);
            const methodStartColIndex = colIndex;
            const methodEndColIndex = colIndex + banks.length;
    
            methodColIndexes[method] = { start: methodStartColIndex, end: methodEndColIndex };
    
            setCell(2, methodStartColIndex, method);
            setCellBorder(2, methodStartColIndex, getBorderStyle('thick'));
    
            for (let i = methodStartColIndex; i <= methodEndColIndex; i++) {
                setCellBorder(3, i, getBorderStyle('thin'));
            }
    
            for (let i = methodStartColIndex; i <= methodEndColIndex; i++) {
                setCellBackgroundColor(0, i, '#d9ead3', 0);
            }
    
            banks.forEach((bank, bankIndex) => {
                const bankColIndex = colIndex + bankIndex;
                const colLetter = String.fromCharCode(66 + bankColIndex - 1);
    
                const cellData = [
                    { row: 3, text: bank },
                    { row: 6, text: calculateAverage(bankPricesMap[method][bank]), format: 'rub' },
                    { row: 7, text: bankCountsMap[method][bank] },
                    { row: 8, text: calculateAverage(bankProfitsMap[method][bank]), format: 'rub' },
                    { row: 10, text: `=${colLetter}8*${colLetter}9`, format: 'rub' },
                    { row: 12, text: `=${colLetter}15/${colLetter}8*100`, format: 'percent' },
                    { row: 13, text: `=${colLetter}7*${colLetter}15`, format: 'rub' },
                    { row: 14, text: bankProblemCountsMap[method]?.[bank] || 0 },
                    { row: 16, text: `=${colLetter}19/${colLetter}8*100`, format: 'percent' },
                    { row: 17, text: bankBlockSumMap[method]?.[bank]?.toFixed(2) || '0.00', format: 'rub' },
                    { row: 18, text: bankBlockCountsMap[method]?.[bank] || 0 },
                    { row: 20, text: `=${colLetter}7*${colLetter}8`, format: 'rub' },
                    { row: 21, text: '0', format: 'percent' },
                    { row: 22, text: `=(${colLetter}11-${colLetter}18)*${colLetter}22`, format: 'rub' },
                    { row: 24, text: `=${colLetter}14+${colLetter}18+${colLetter}21+${colLetter}23`, format: 'rub' },
                    { row: 25, text: `=${colLetter}11-${colLetter}25`, format: 'rub' },
                ];
    
                cellData.forEach(({ row, text, format }) => {
                    setCell(row, bankColIndex, text, format);
                });
            });
    
            const totalColIndex = colIndex + banks.length;
            const totalColLetter = String.fromCharCode(66 + totalColIndex - 1);
    
            setCell(2, totalColIndex, `Итого ${method}`);
            setCellBorder(2, totalColIndex, getBorderStyle('thick'));
    
            const bankColLetters = banks.map((_, index) => String.fromCharCode(66 + (colIndex + index) - 1));
    
            const totalCellData = [
                { row: 6, text: `=AVERAGE(${bankColLetters.map(l => l + '7').join(',')})`, format: 'rub' },
                { row: 7, text: `=SUM(${bankColLetters.map(l => l + '8').join(',')})` },
                { row: 8, text: `=AVERAGE(${bankColLetters.map(l => l + '9').join(',')})`, format: 'rub' },
                { row: 10, text: `=SUM(${bankColLetters.map(l => l + '11').join(',')})`, format: 'rub' },
                { row: 12, text: `=${totalColLetter}15/${totalColLetter}8*100`, format: 'percent' },
                { row: 13, text: `=SUM(${bankColLetters.map(l => l + '14').join(',')})`, format: 'rub' },
                { row: 14, text: `=SUM(${bankColLetters.map(l => l + '15').join(',')})` },
                { row: 16, text: `=${totalColLetter}19/${totalColLetter}8*100`, format: 'percent' },
                { row: 17, text: Object.values(bankBlockSumMap[method] || {}).reduce((a, b) => a + b, 0).toFixed(2), format: 'rub' },
                { row: 18, text: `=SUM(${bankColLetters.map(l => l + '19').join(',')})` },
                { row: 20, text: `=SUM(${bankColLetters.map(l => l + '21').join(',')})`, format: 'rub' },
                { row: 21, text: `=AVERAGE(${bankColLetters.map(l => l + '22').join(',')})`, format: 'percent' },
                { row: 22, text: `=SUM(${bankColLetters.map(l => l + '23').join(',')})`, format: 'rub' },
                { row: 24, text: `=SUM(${bankColLetters.map(l => l + '25').join(',')})`, format: 'rub' },
                { row: 25, text: `=${totalColLetter}11-${totalColLetter}25`, format: 'rub' },
            ];
    
            totalCellData.forEach(({ row, text, format }) => {
                setCell(row, totalColIndex, text, format);
            });
    
            colIndex = totalColIndex + 1;
        });
    
        setCell(0, colIndex, 'итого Процессинг');
        setCellBorder(0, colIndex, getBorderStyle('thick'));
        setCellBackgroundColor(0, colIndex, '#d9ead3', 0);
    
        const totalColLetter = String.fromCharCode(66 + colIndex - 1);
    
        const processingCellData = [
            { row: 6, text: averagePrice, format: 'rub' },
            { row: 7, text: totalBanksCount },
            { row: 8, text: averageProfit, format: 'rub' },
            { row: 10, text: sumProfit, format: 'rub' },
            { row: 12, text: `=${totalColLetter}15/${totalColLetter}8*100`, format: 'percent' },
            { row: 13, text: `=${totalColLetter}7*${totalColLetter}15`, format: 'rub' },
            { row: 14, text: totalProblemCount },
            { row: 16, text: `=${totalColLetter}19/${totalColLetter}8*100`, format: 'percent' },
            { row: 17, text: totalBlockAmount.toFixed(2), format: 'rub' },
            { row: 18, text: totalBlockCount },
            { row: 20, text: `=${totalColLetter}7*${totalColLetter}8`, format: 'rub' },
            { row: 21, text: '0', format: 'percent' },
            { row: 22, text: `=(${totalColLetter}11-${totalColLetter}18)*${totalColLetter}22`, format: 'rub' },
            { row: 24, text: `=${totalColLetter}14+${totalColLetter}18+${totalColLetter}21+${totalColLetter}23`, format: 'rub' },
            { row: 25, text: `=${totalColLetter}11-${totalColLetter}25`, format: 'rub' },
        ];
    
        processingCellData.forEach(({ row, text, format }) => {
            setCell(row, colIndex, text, format);
        });
    
        for (let i = 1; i <= colIndex; i++) {
            setCellBackgroundColor(0, i, '#d9ead3', 0);
        }
    
        return { colIndex, methodColIndexes };
    
        function calculateAverage(values) {
            if (values && values.length) {
                return (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2);
            }
            return '0.00';
        }
    }
    
    function renderOperationTypes(filteredRecordsDB2, { colIndex, methodColIndexes }, exchangeRate) {
        const excludedOperations = new Set([
            "Пересчёт кассы",
            "Внесение Слава",
            "Внесение Patek",
            "Внесение Роман",
            "Вывод Роман",
            "Вывод Слава",
            "Вывод Patek",
            "Выплаты Consulting",
            "Доход от рефералов",
            "Расходы на дропов",
            "Апелляция",
            "Перевод (получаем на счёт)",
            "Перевод (снимаем с счёта)"
        ]);
    
        const projectsToProcess = ['Процессинг//Переводы', 'Процессинг//Наличка'];
        const cashInProject = 'Cash-In//';
    
        let currentRowIndex = 28; // Начальная строка для вывода данных
    
        // Инициализация сумм
        const totalSumsDB2 = {
            'Процессинг//Переводы': 0,
            'Процессинг//Наличка': 0,
            'Итого': 0
        };
    
        // Вспомогательные функции
    
        function addSum(operationSums, operation, project, sum) {
            if (!operationSums[operation]) {
                operationSums[operation] = {};
            }
            if (!operationSums[operation][project]) {
                operationSums[operation][project] = 0;
            }
            operationSums[operation][project] += sum;
        }
    
        function convertToRubles(amount) {
            return exchangeRate ? (amount * exchangeRate).toFixed(2) : amount.toFixed(2);
        }
    
        // Инициализация операций и сумм для DB2
        const uniqueOperationsDB2 = new Set();
        const operationSumsDB2 = {};
    
        // Обработка операций для DB2
        filteredRecordsDB2.forEach(record => {
            const { 'Бухгалтерия_Операция': operation, 'Бухгалтерия_Проект': project, 'Бухгалтерия_Сумма': amount } = record;
            const sum = parseFloat(amount);
    
            if (!operation || excludedOperations.has(operation) || isNaN(sum)) {
                return;
            }
    
            if (projectsToProcess.includes(project)) {
                addSum(operationSumsDB2, operation, project, sum);
                uniqueOperationsDB2.add(operation);
            }
        });
    
        // Обработка уникальных операций для DB2
        uniqueOperationsDB2.forEach(operation => {
            setCell(currentRowIndex, 0, operation);
    
            const переводSum = operationSumsDB2[operation]['Процессинг//Переводы'] || 0;
            const наличкаSum = operationSumsDB2[operation]['Процессинг//Наличка'] || 0;
    
            const переводSumRub = convertToRubles(переводSum);
            const наличкаSumRub = convertToRubles(наличкаSum);
    
            const totalProcessingSumRub = (parseFloat(переводSumRub) + parseFloat(наличкаSumRub)).toFixed(2);
    
            // Установка сумм в ячейки
            setCell(currentRowIndex, colIndex, totalProcessingSumRub, 'rub');
    
            if (methodColIndexes['Переводы']) {
                const methodTotalColIndex = methodColIndexes['Переводы'].end;
                setCell(currentRowIndex, methodTotalColIndex, переводSumRub, 'rub');
                totalSumsDB2['Процессинг//Переводы'] += parseFloat(переводSumRub);
            }
    
            if (methodColIndexes['Наличка']) {
                const methodTotalColIndex = methodColIndexes['Наличка'].end;
                setCell(currentRowIndex, methodTotalColIndex, наличкаSumRub, 'rub');
                totalSumsDB2['Процессинг//Наличка'] += parseFloat(наличкаSumRub);
            }
    
            totalSumsDB2['Итого'] += parseFloat(totalProcessingSumRub);
    
            currentRowIndex++;
        });
    
        // Остальная часть обработки DB2 (итоги, формулы) остается без изменений
    
        const rubleSubTotalRowIndexDB2 = currentRowIndex + 1;
    
        currentRowIndex++;
        setCell(currentRowIndex, 0, "₽ DB 2");
    
        const totalColLetterDB2 = String.fromCharCode(65 + colIndex);
        const db2Formula = `=${totalColLetterDB2}26 - ${totalColLetterDB2}${rubleSubTotalRowIndexDB2}`;
        setCell(currentRowIndex, colIndex, db2Formula, 'rub');
    
        // Переход к DB3
        currentRowIndex += 2;
        const db3StartRowIndex = currentRowIndex;
    
        // Обработка операций для DB3
        const processingOperationsDB3 = {};
        filteredRecordsDB2.forEach(record => {
            const { 'Бухгалтерия_Операция': operation, 'Бухгалтерия_Проект': project, 'Бухгалтерия_Сумма': amount } = record;
            const sum = parseFloat(amount);
    
            if (
                operation &&
                !excludedOperations.has(operation) &&
                (
                    (project.startsWith('Процессинг//') && !projectsToProcess.includes(project)) ||
                    project === cashInProject
                ) &&
                !isNaN(sum)
            ) {
                if (!processingOperationsDB3[operation]) {
                    processingOperationsDB3[operation] = {};
                }
                if (!processingOperationsDB3[operation][project]) {
                    processingOperationsDB3[operation][project] = 0;
                }
                processingOperationsDB3[operation][project] += sum;
            }
        });
    
        // Собираем список проектов в DB3
        const projectsDB3 = new Set();
        Object.values(processingOperationsDB3).forEach(projectSums => {
            Object.keys(projectSums).forEach(project => {
                projectsDB3.add(project);
            });
        });
    
        // Обновляем methodColIndexes для новых проектов
        projectsDB3.forEach(project => {
            if (!methodColIndexes[project]) {
                colIndex += 1;
                methodColIndexes[project] = { start: colIndex, end: colIndex };
                setCellText(0, colIndex, project);
            }
        });
    
        // Обновляем totalTotalsColIndex
        const totalTotalsColIndex = colIndex + 1;
        setCellText(0, totalTotalsColIndex, "Итоги Итогов:");
    
        // Обработка уникальных операций в DB3
        let processingTotalSumDB3 = 0;
        Object.keys(processingOperationsDB3).forEach(operation => {
            setCell(currentRowIndex, 0, operation);
    
            let operationTotalSumRub = 0;
    
            projectsDB3.forEach(project => {
                const sum = processingOperationsDB3[operation][project] || 0;
    
                if (sum !== 0) {
                    const sumRub = convertToRubles(sum);
    
                    const projectColIndex = methodColIndexes[project].end;
    
                    setCell(currentRowIndex, projectColIndex, sumRub, 'rub');
    
                    operationTotalSumRub += parseFloat(sumRub);
                }
            });
    
            // Устанавливаем общую сумму по операции
            setCell(currentRowIndex, totalTotalsColIndex, operationTotalSumRub.toFixed(2), 'rub');
    
            processingTotalSumDB3 += operationTotalSumRub;
    
            currentRowIndex++;
        });
    
        currentRowIndex += 2;
    
        // Итоговые строки для DB3
        const totalSumsDB3 = {};
        projectsDB3.forEach(project => {
            totalSumsDB3[project] = 0;
        });
    
        Object.values(processingOperationsDB3).forEach(projectSums => {
            projectsDB3.forEach(project => {
                const sumRub = parseFloat(convertToRubles(projectSums[project] || 0));
                totalSumsDB3[project] += sumRub;
            });
        });
    
        setCell(currentRowIndex, 0, "₽ Итого: фикс косты на направление");
    
        projectsDB3.forEach(project => {
            const projectColIndex = methodColIndexes[project].end;
            const totalSum = totalSumsDB3[project].toFixed(2);
            setCell(currentRowIndex, projectColIndex, totalSum, 'rub');
        });
    
        const totalSumDB3 = Object.values(totalSumsDB3).reduce((a, b) => a + b, 0);
        setCell(currentRowIndex, totalTotalsColIndex, totalSumDB3.toFixed(2), 'rub');
    
        const rubleTotalRowIndexDB3 = currentRowIndex + 1;
    
        currentRowIndex++;
        setCell(currentRowIndex, 0, "₽ DB 3");
    
        projectsDB3.forEach(project => {
            const projectColIndex = methodColIndexes[project].end;
            const projectColLetter = String.fromCharCode(65 + projectColIndex);
            const formula = `=${projectColLetter}${db3StartRowIndex} - ${projectColLetter}${rubleTotalRowIndexDB3}`;
            setCell(currentRowIndex, projectColIndex, formula, 'rub');
        });
    
        const totalColLetterDB2 = String.fromCharCode(65 + totalTotalsColIndex);
        const db3Formula = `=${totalColLetterDB2}${rubleSubTotalRowIndexDB2 + 1} - ${totalColLetterDB2}${rubleTotalRowIndexDB3}`;
        setCell(currentRowIndex, totalTotalsColIndex, db3Formula, 'rub');
    
        // Добавление границ и стилей
        addBordersAndStyles();
    
        // Вспомогательная функция для добавления границ и стилей
        function addBordersAndStyles() {
            const borderStartRow = 0;
            const borderEndRow = currentRowIndex;
    
            // Добавление правых границ для методов
            Object.values(methodColIndexes).forEach(({ end: lastColIndex }) => {
                for (let ri = borderStartRow; ri <= borderEndRow; ri++) {
                    setCellBorder(ri, lastColIndex, {
                        right: [defaultBorderStyle.style, defaultBorderStyle.color]
                    }, 0);
                }
            });
    
            // Добавление правых границ для дополнительных колонок
            const additionalBordersColIndexes = [
                0,
                colIndex,
                totalTotalsColIndex
            ];
    
            additionalBordersColIndexes.forEach(targetColIndex => {
                for (let ri = borderStartRow; ri <= borderEndRow; ri++) {
                    const borderStyle = getBorderStyle(
                        targetColIndex === 0 || targetColIndex === colIndex || targetColIndex === totalTotalsColIndex
                            ? 'thick'
                            : 'thin'
                    );
                    setCellBorder(ri, targetColIndex, {
                        right: [borderStyle.right[0], borderStyle.right[1]]
                    }, 0);
                }
            });
    
            // Добавление горизонтальных линий под каждым DB
            const dbRows = [25, rubleSubTotalRowIndexDB2, rubleTotalRowIndexDB3];
    
            dbRows.forEach(dbRow => {
                for (let col = 0; col <= totalTotalsColIndex; col++) {
                    setCellBorder(dbRow, col, {
                        bottom: ['thin', '#000000']
                    }, 0);
                }
            });
    
            // Добавление верхней границы
            for (let col = 0; col <= totalTotalsColIndex; col++) {
                setCellBorder(0, col, {
                    bottom: ['thin', '#000000']
                }, 0);
            }
        }
    }
        
</script>
    
<script>

    // math.js
    
    /********** STYLE FUNCTIONS **********/
    function setCellStyle(ri, ci, property, value, sheetIndex = 0) {
        const { styles, rows } = s.datas[sheetIndex];
        const cell = rows.getCellOrNew(ri, ci);
        let cstyle = cell.style !== undefined ? { ...styles[cell.style] } : {};
    
        if (property === 'format') {
            cstyle.format = value;
        } else if (property.startsWith('font')) {
            const [fontProp] = property.split('-').slice(1);
            cstyle.font = { ...(cstyle.font || {}), [fontProp]: value };
        } else if (property === 'border') {
            cstyle.border = { ...(cstyle.border || {}), ...value };
        } else {
            cstyle[property] = value;
        }
    
        cell.style = s.datas[sheetIndex].addStyle(cstyle);
    }
    
    
    const setCellBorder = (ri, ci, borderStyle, sheetIndex = 0) => setCellStyle(ri, ci, 'border', borderStyle, sheetIndex);
    const setCellBackgroundColor = (row, col, color, sheetIndex = 0) => setCellStyle(row, col, 'bgcolor', color, sheetIndex);
    const enableTextWrap = (row, col, sheetIndex = 0) => setCellStyle(row, col, 'textwrap', true, sheetIndex);
    
    /********** DIMENSION FUNCTIONS **********/
    function setColumnWidth(colIndex, width, sheetIndex = 0) {
        s.datas[sheetIndex].cols.setWidth(colIndex, width);
    }
    
    function setRowHeight(rowIndex, height, sheetIndex = 0) {
        s.datas[sheetIndex].rows.setHeight(rowIndex, height);
    }
    
    /********** TEXT FUNCTIONS **********/
    function setCellText(row, col, text, sheetIndex = 0) {
        const cell = s.datas[sheetIndex].rows.getCellOrNew(row, col);
        cell.text = text;
    }
    
    /********** INITIALIZATION FUNCTIONS **********/
    const defaultBorderStyle = { style: 'thin', color: '#000000' };
    const thickBorderStyle = { style: 'thick', color: '#000000' }; 
    
    const getBorderStyle = style => ({
        top: [style, defaultBorderStyle.color],
        bottom: [style, defaultBorderStyle.color],
        right: [style, defaultBorderStyle.color],
        left: [style, defaultBorderStyle.color]
    });
    
    function initializeSpreadsheetDB() {
        [[0, 0], [0, 1]].forEach(([row, col]) => setCellBorder(row, col, getBorderStyle('thick')));
        [[0, 0, 'Статья'], [0, 1, 'Процессинг']].forEach(([row, col, text]) => setCellText(row, col, text, 0));
        [[0, 150], [1, 150]].forEach(([col, width]) => setColumnWidth(col, width, 0));
        setRowHeight(0, 30, 0);
        [[0, 0], [0, 1]].forEach(([row, col]) => enableTextWrap(row, col, 0));
        [
            { row: 6, text: 'Цена закуп. карты' },
            { row: 7, text: 'Кол-во карт' },
            { row: 8, text: 'Профит с 1 карты' },
            { row: 10, text: 'Выручка наша:' },
            { row: 12, text: '% проблемных' },
            { row: 13, text: 'Сумма замороженных денег в проблемных картах' },
            { row: 14, text: 'Кол-во карт проблемных' },
            { row: 16, text: '% блока' },
            { row: 17, text: 'Сумма в блоки (заморозка)' },
            { row: 18, text: 'Кол-во карт в блок' },
            { row: 20, text: 'закуп карточки' },
            { row: 21, text: '% парней с выручки на руки' },
            { row: 22, text: 'ФОТ операторы' },
            { row: 24, text: 'Итого: переменные косты на подподнаправления' },
            { row: 25, text: 'DB 1' }
        ].forEach(({ row, text }) => setCellText(row, 0, text, 0));
    }
    
    /********** DYNAMIC RENDERING FUNCTIONS **********/
    function renderUniqueBankValues(filteredRecordsDB1, filteredRecordsDB2) {
        const bankData = processBankRecords(filteredRecordsDB1);
        const { colIndex, methodColIndexes } = renderBankData(bankData); 
        renderOperationTypes(filteredRecordsDB2, { colIndex, methodColIndexes }, exchangeRate); 
        s.reRender();
    }
    
</script>
<script>

    // main.js
    
    // Инициализация Grist и x-spreadsheet
    grist.ready({
        columns: [
            'Банк', 'Цена', 'Профит', 'Статус', 'Выплачено', 'Дроповод', 'Дата_BLOCK', 'BLOCK',
            'Приёмка', 'Метод', 'Площадка', 'Бухгалтерия_Дата', 'Бухгалтерия_Проект',
            'Бухгалтерия_Операция', 'Бухгалтерия_Сумма', 'Бухгалтерия_Курс_Usd_Rub'
        ],
        requiredAccess: 'read table'
    });
    
    const s = x_spreadsheet("#x-spreadsheet-demo");
    
    let mappedRecords = [];
    const fieldsForDB1 = [
        'Банк', 'Цена', 'Профит', 'Статус', 'Выплачено', 'Дроповод', 'Дата_BLOCK',
        'Приёмка', 'Метод', 'Площадка'
    ];
    const fieldsForDB2 = [
        'Бухгалтерия_Дата', 'Бухгалтерия_Проект', 'Бухгалтерия_Операция',
        'Бухгалтерия_Сумма', 'Бухгалтерия_Курс_Usd_Rub'
    ];
    
    let exchangeRate = null;
    
    
    grist.onRecords(records => {
        mappedRecords = grist.mapColumnNames(records);
        exchangeRate = getExchangeRate(mappedRecords); // Извлекаем курс из всех записей
        populateFilterOptions(); // Вызов из UI.js
        setupFilterEventListeners(); // Регистрация обработчиков событий
        applyFiltersAndRender();
    });
    
    function getExchangeRate(records) {
        for (let record of records) {
            if (record['Бухгалтерия_Курс_Usd_Rub']) {
                return parseFloat(record['Бухгалтерия_Курс_Usd_Rub']);
            }
        }
        return null;
    }
    
    function applyFiltersAndRender() {
        const filteredRecordsDB1 = mappedRecords.filter(applyCustomFiltersDB1);
        const filteredRecordsDB2 = mappedRecords.filter(applyCustomFiltersDB2);
    
        s.loadData([
            { name: 'DB', freeze: 'B5', rows: {} },
            {
                name: 'Таблица для DB 1',
                rows: createRowsData(filteredRecordsDB1, fieldsForDB1)
            },
            {
                name: 'Таблица для DB 2',
                rows: createRowsData(filteredRecordsDB2, fieldsForDB2)
            }
        ]);
        s.reRender();
    
        initializeSpreadsheetDB();
        renderUniqueBankValues(filteredRecordsDB1, filteredRecordsDB2);
    }
    
    // Функция создания данных для таблицы
    const createRowsData = (records, fields) => ({
        len: records.length,
        ...Object.fromEntries(records.map((record, rowIndex) => [
            rowIndex,
            {
                cells: Object.fromEntries(fields.map((field, colIndex) => [
                    colIndex,
                    { text: record[field] != null ? (Array.isArray(record[field]) ? record[field].join(', ') : String(record[field])) : '' }
                ]))
            }
        ]))
    });
    
</script>

    
</body>
</html>
